# -*- coding: utf-8 -*-
"""Final Year Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1b_zs4YDGv6E8u7eOGltflywhORU0acPN
"""

from google.colab import drive
drive.mount('/content/drive')

"""#### Loading Datasets"""

import datetime, warnings, scipy 
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

flightsinfo = pd.read_csv("drive/My Drive/flights.csv",nrows=50000)
airport = pd.read_csv('drive/My Drive/airports.csv')
airlines = pd.read_csv('drive/My Drive/airlines.csv')
flightsinfo

"""#### Exploring and Analyzing Dataset
We are displaying data type of every feature in flights dataset. This will help in understadning of data and further analysis.
"""

flightsinfo.dtypes

list(flightsinfo.columns)

flightsinfo.head()

flightsinfo.describe()

airlinecompanies = airlines.set_index('IATA_CODE')['AIRLINE'].to_dict()

airlinecompanies

airport.isnull().sum()

airport = airport.dropna(subset = ['LATITUDE','LONGITUDE']) #dropping na values of Latitude and Longitude

airport.isnull().sum()

airport.head(10)

airlines

flightsinfo.isnull().sum()

"""## Data Cleaning"""

flightsinfo1 = flightsinfo.dropna(subset = ["TAIL_NUMBER",'DEPARTURE_TIME','DEPARTURE_DELAY','TAXI_OUT','WHEELS_OFF','SCHEDULED_TIME',
'ELAPSED_TIME','AIR_TIME','WHEELS_ON','TAXI_IN','ARRIVAL_TIME','ARRIVAL_DELAY'])  #dropping missing values in the dataset

flightsinfo1.shape

flightsinfo1.isnull().sum()

flightsinfo_modified = flightsinfo1.dropna(subset = ['AIR_SYSTEM_DELAY','SECURITY_DELAY','AIRLINE_DELAY','LATE_AIRCRAFT_DELAY','WEATHER_DELAY'])
flightsinfo_modified = flightsinfo_modified.drop(['YEAR','MONTH','DAY','DAY_OF_WEEK','TAIL_NUMBER','SCHEDULED_DEPARTURE','DEPARTURE_TIME','SCHEDULED_TIME',
                     'SCHEDULED_ARRIVAL','ARRIVAL_TIME','DIVERTED','CANCELLED','CANCELLATION_REASON','FLIGHT_NUMBER','WHEELS_OFF',
                     'WHEELS_ON','AIR_TIME'],axis = 1)

flightsinfo_modified.info()

Flight_Delays = flightsinfo_modified

flightsinfo2 = flightsinfo1.drop(['CANCELLATION_REASON','AIR_SYSTEM_DELAY','SECURITY_DELAY','AIRLINE_DELAY',
                    'LATE_AIRCRAFT_DELAY','WEATHER_DELAY'],axis = 1)

flightsinfo2.isnull().sum()

flightsinfo2.shape

flightsinfo2.info()

flightsinfo2.DEPARTURE_TIME.dtype

flightsinfo2.DEPARTURE_TIME

"""The times are not in the correct format so i will transform them into HH:MM format

"""

def CreateTimeFormatted(hours):
        if hours == 2400:
            hours = 0
        else:
            hours = "{0:04d}".format(int(hours))
            Hourmin = datetime.time(int(hours[0:2]), int(hours[2:4]))
            return Hourmin

flightsinfo2['Actual_Departure'] =flightsinfo1['DEPARTURE_TIME'].apply(CreateTimeFormatted)
flightsinfo2['Scheduled_Arrival'] =flightsinfo1['SCHEDULED_ARRIVAL'].apply(CreateTimeFormatted)
flightsinfo2['Scheduled_Departure'] =flightsinfo1['SCHEDULED_DEPARTURE'].apply(CreateTimeFormatted)
flightsinfo2['Actual_Arrival'] =flightsinfo2['ARRIVAL_TIME'].apply(CreateTimeFormatted)

flightsinfo2.columns

flightsinfo2 = flightsinfo2.merge(airlines, left_on='AIRLINE', right_on='IATA_CODE', how='inner')

flightsinfo2.columns

flightsinfo2 = flightsinfo2.drop(['AIRLINE_x','IATA_CODE'], axis=1)

flightsinfo2 = flightsinfo2.rename(columns={"AIRLINE_y":"AIRLINE"})

flightsinfo2.columns

flightsinfo2 = flightsinfo2.merge(airport, left_on='ORIGIN_AIRPORT', right_on='IATA_CODE', how='inner')
flightsinfo2 = flightsinfo2.merge(airport, left_on='DESTINATION_AIRPORT', right_on='IATA_CODE', how='inner')

flightsinfo2.columns

flightsinfo2 = flightsinfo2.rename(columns={'IATA_CODE_x':'Org_Airport_Code','AIRPORT_x':'Org_Airport_Name','CITY_x':'Origin_city',
                             'IATA_CODE_y':'Dest_Airport_Code','AIRPORT_y':'Dest_Airport_Name','CITY_y':'Destination_city'})

flightsinfo2

data_vizual = pd.DataFrame(flightsinfo2[['AIRLINE','Org_Airport_Name','Origin_city',
                               'Dest_Airport_Name','Destination_city','ORIGIN_AIRPORT',
                               'DESTINATION_AIRPORT','DISTANCE','Actual_Departure',
                               'Scheduled_Departure','DEPARTURE_DELAY','Actual_Arrival','Scheduled_Arrival','ARRIVAL_DELAY',
                              'SCHEDULED_TIME','ELAPSED_TIME','AIR_TIME','TAXI_IN','TAXI_OUT','DIVERTED',]])

flightsinfo2.DEPARTURE_TIME.dtype

data_vizual = data_vizual.dropna(subset = ['Actual_Departure','Actual_Arrival'])

data_vizual.info()

Flights = data_vizual
Flights

"""### Data Visualization"""

plt.figure(figsize=(10, 10))
axis = sns.countplot(y=Flights['Origin_city'], data = Flights,
              order=Flights['Origin_city'].value_counts().iloc[:20].index,palette="Set2")
axis.set_yticklabels(axis.get_yticklabels())
plt.tight_layout()
plt.show()

axis = plt.subplots(figsize=(10,10))
sns.despine(bottom=True, left=True)
sns.stripplot(x="ARRIVAL_DELAY", y="AIRLINE",data = Flights, dodge=True, jitter=True,palette="Set1")
plt.show()

axis = plt.subplots(figsize=(18,12))

Flightscorr=pd.DataFrame(Flights[['DISTANCE','DEPARTURE_DELAY','SCHEDULED_TIME','AIR_TIME','TAXI_IN','TAXI_OUT']])
Flightscorr['Is_Delayed'] = np.where(Flights['ARRIVAL_DELAY']<=0, 0,1)
sns.heatmap(Flightscorr.corr(),annot = True,cmap="YlGnBu")

b, t = plt.ylim() # discover the values for bottom and top
#b += 0.5 # Add 0.5 to the bottom
t -= 0.5 # Subtract 0.5 from the top
plt.ylim(b, t) # update the ylim(bottom, top) values
plt.show()

plt.figure(figsize=(10, 10))
axis = sns.countplot(x=Flights['ORIGIN_AIRPORT'], data =Flights,
              order=Flights['ORIGIN_AIRPORT'].value_counts().iloc[:20].index)
axis.set_xticklabels(axis.get_xticklabels(), rotation=90, ha="right")
plt.tight_layout()
plt.show()

axis = plt.subplots(figsize=(10,14))
Name = Flights["AIRLINE"].unique()
size = Flights["AIRLINE"].value_counts()
plt.pie(size,labels=Name,autopct='%5.0f%%')
plt.show()

delay_type = lambda x:((0,1)[x > 5],2)[x > 45]
flightsinfo['DELAY_LEVEL'] = flightsinfo['DEPARTURE_DELAY'].apply(delay_type)

fig = plt.figure(1, figsize=(10,7))
ax = sns.countplot(x="AIRLINE", hue='DELAY_LEVEL', data=flightsinfo, palette= ["#00FF00","#FFA500","#FF0000"])

labels = ax.get_xticklabels()
ax.set_xticklabels(labels)
plt.setp(ax.get_yticklabels(), fontsize=12, weight = 'normal', rotation = 0);
plt.setp(ax.get_xticklabels(), fontsize=12, weight = 'normal', rotation = 0);
ax.xaxis.label.set_visible(False)
plt.ylabel('No. of Flights', fontsize=16, weight = 'bold', labelpad=10)

L = plt.legend()
L.get_texts()[0].set_text('on time (t < 5 min)')
L.get_texts()[1].set_text('small delay (5 < t < 45 min)')
L.get_texts()[2].set_text('large delay (t > 45 min)')
plt.show()

Flights1 = Flights.drop(['Org_Airport_Name','Origin_city','Dest_Airport_Name','Destination_city'],axis = 1)

Flights1.columns

"""## Predicting whether the flight is Delayed or Not"""

from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder

le = LabelEncoder()

"""Applying Label encoder to convert text values to numbers"""

Flights1['AIRLINE']= le.fit_transform(Flights1['AIRLINE'])

Flights1['ORIGIN_AIRPORT'] = le.fit_transform(Flights1['ORIGIN_AIRPORT'])

Flights1['DESTINATION_AIRPORT'] = le.fit_transform(Flights1['DESTINATION_AIRPORT'])
mapping = dict(zip(le.classes_, range(len(le.classes_))))
mapping
mapping

Flights1 = Flights1.drop(['Scheduled_Departure','Scheduled_Arrival','Actual_Arrival','Actual_Departure','ELAPSED_TIME','DIVERTED','TAXI_IN'], axis = 1)

"""Creating a new feature which has value only as 0 or 1 depending on it it is delayed or not"""

Flights1['Is_Delayed'] = np.where(Flights1['ARRIVAL_DELAY']<=0, 0,1)

Flights1

X = Flights1.drop(['ARRIVAL_DELAY','Is_Delayed'],axis = 1)
X.shape
y = Flights1['Is_Delayed']
y.head()

X

y

X_train,X_test,y_train,y_test = train_test_split(X,y,test_size=0.2,random_state = 2)

y_train.value_counts()

"""### KNN Classification"""

from sklearn.metrics import accuracy_score, f1_score, precision_score, recall_score, classification_report, confusion_matrix
from sklearn.metrics import plot_confusion_matrix

from sklearn.neighbors import KNeighborsClassifier  
classifierKNN= KNeighborsClassifier(n_neighbors=5, metric='minkowski', p=2 )  
classifierKNN.fit(X_train, y_train)

# Predicting the Test set results
y_pred = classifierKNN.predict(X_test)

# Making the Confusion Matrix
from sklearn.metrics import confusion_matrix
cm = confusion_matrix(y_test, y_pred)
score = classifierKNN.score(X_test,y_test)

cm

score

print("F1 score :",f1_score(y_test, y_pred, average="macro"))
print("Precision Score :" , precision_score(y_test, y_pred, average="macro"))
print("Recall Score :" , recall_score(y_test, y_pred, average="macro"))

fig, ax = plt.subplots(figsize=(5, 5))
plot_confusion_matrix(classifierKNN, X_test, y_test, normalize='true', cmap=plt.cm.Blues, ax=ax)
plt.show()

df = pd.DataFrame({'Actual': y_test, 'Predicted': y_pred})
df

X_val=np.array([[3,187,229,69,1.0,35,24.0,11.0]])

X_val

y_pred_val = classifierKNN.predict(X_val)

y_pred_val

"""### Decision Tree Classification"""

from sklearn.tree import DecisionTreeClassifier
classifierDT = DecisionTreeClassifier(criterion = 'entropy', random_state = None)
classifierDT.fit(X_train, y_train)

from sklearn.metrics import accuracy_score, f1_score, precision_score, recall_score, classification_report, confusion_matrix

from sklearn.metrics import plot_confusion_matrix

# Predicting the Test set results
y_pred = classifierDT.predict(X_test)

# Making the Confusion Matrix
cm = confusion_matrix(y_test, y_pred)
score = classifierDT.score(X_test,y_test)

cm

score

print("F1 score :",f1_score(y_test, y_pred, average="macro"))
print("Precision Score :" , precision_score(y_test, y_pred, average="macro"))
print("Recall Score :" , recall_score(y_test, y_pred, average="macro"))

fig, ax = plt.subplots(figsize=(5, 5))
plot_confusion_matrix(classifierDT, X_test, y_test, normalize='true', cmap=plt.cm.Blues, ax=ax)
plt.show()

df = pd.DataFrame({'Actual': y_test, 'Predicted': y_pred})
df

X_val=np.array([[3,187,229,69,1.0,35,24.0,11.0]])

X_val

y_pred_val = classifierDT.predict(X_val)

y_pred_val

"""### Random Forest Classification"""

from sklearn.ensemble import RandomForestClassifier
classifierRF = RandomForestClassifier(criterion = 'entropy', random_state = None,n_estimators=1000)
classifierRF.fit(X_train, y_train)
X_train

from sklearn.metrics import accuracy_score, f1_score, precision_score, recall_score, classification_report, confusion_matrix

from sklearn.metrics import plot_confusion_matrix

# Predicting the Test set results
y_pred = classifierRF.predict(X_test)

# Making the Confusion Matrix
cm = confusion_matrix(y_test, y_pred)
score = classifierRF.score(X_test,y_test)

cm

score

X_test

print("F1 score :",f1_score(y_test, y_pred, average="macro"))
print("Precision Score :" , precision_score(y_test, y_pred, average="macro"))
print("Recall Score :" , recall_score(y_test, y_pred, average="macro"))

fig, ax = plt.subplots(figsize=(5, 5))
plot_confusion_matrix(classifierRF, X_test, y_test, normalize='true', cmap=plt.cm.Blues, ax=ax)
plt.show()

df = pd.DataFrame({'Actual': y_test, 'Predicted': y_pred})
df

X_val=np.array([[3,187,229,69,1.0,35,24.0,11.0]])

X_val

y_pred_val = classifierRF.predict(X_val)

y_pred_val

"""### XGBoost Classification"""

from xgboost import XGBClassifier
classifierXGB = XGBClassifier(n_estimators=2000)
classifierXGB.fit(X_train, y_train)

from sklearn.metrics import accuracy_score, f1_score, precision_score, recall_score, classification_report, confusion_matrix

from sklearn.metrics import plot_confusion_matrix

# Predicting the Test set results
y_pred = classifierXGB.predict(X_test)

# Making the Confusion Matrix
cm = confusion_matrix(y_test, y_pred)
score = classifierXGB.score(X_test,y_test)

cm

score

X_test

print("F1 score :",f1_score(y_test, y_pred, average="macro"))
print("Precision Score :" , precision_score(y_test, y_pred, average="macro"))
print("Recall Score :" , recall_score(y_test, y_pred, average="macro"))

fig, ax = plt.subplots(figsize=(5, 5))
plot_confusion_matrix(classifierRF, X_test, y_test, normalize='true', cmap=plt.cm.Blues, ax=ax)
plt.show()

df = pd.DataFrame({'Actual': y_test, 'Predicted': y_pred})
df

X_val=np.array([[3,187,229,69,1.0,35,24.0,11.0]])

X_val

y_pred_val = classifierRF.predict(X_val)

y_pred_val

"""testing"""

totalcount=Flights1.loc[(Flights1['AIRLINE'] == 0) & (Flights1['ORIGIN_AIRPORT'] == 15) & (Flights1['DESTINATION_AIRPORT'] == 265)]['Is_Delayed'].count()
totalcount

delayedcount=Flights1.loc[(Flights1['AIRLINE'] == 0) & (Flights1['ORIGIN_AIRPORT'] == 15) & (Flights1['DESTINATION_AIRPORT'] == 265) & (Flights1['Is_Delayed'] == 1)]['Is_Delayed'].count()
delayedcount

nodelayedcount=Flights1.loc[(Flights1['AIRLINE'] == 0) & (Flights1['ORIGIN_AIRPORT'] == 15) & (Flights1['DESTINATION_AIRPORT'] == 265) & (Flights1['Is_Delayed'] == 0)]['Is_Delayed'].count()
nodelayedcount

axis = plt.subplots(figsize=(10,14))
Name = ['Delayed','Not Delayed']
values = [(delayedcount/totalcount)*100,(nodelayedcount/totalcount)*100]

plt.pie(values,labels=Name,autopct='%5.0f%%')
plt.show() 
# plt.pie(size,labels=Name,autopct='%5.0f%%')
# plt.show()

Flights1 = Flights.drop(['Org_Airport_Name','Origin_city','Dest_Airport_Name','Destination_city','TAXI_IN','TAXI_OUT','DIVERTED','SCHEDULED_TIME'],axis = 1)
Flights1['Is_Delayed'] = np.where(Flights1['ARRIVAL_DELAY']<=0, 0,1)
Flights1.loc[(Flights1['Is_Delayed'] == 1) &  (Flights1['DEPARTURE_DELAY'] <0)].sort_values(by=['DEPARTURE_DELAY'])[:10]

Flights1.loc[(Flights1['Is_Delayed'] == 0) &  (Flights1['DEPARTURE_DELAY'] >0)].sort_values(by=['DEPARTURE_DELAY'])[-10:]

dfnew = pd.DataFrame(Flights1)

corrMatrix = dfnew.corr()
sns.heatmap(corrMatrix, annot=True)
plt.show()
Flights1.columns

"""### Random Forest Regression"""

from sklearn.ensemble import RandomForestRegressor
Rfc = RandomForestRegressor(random_state=2)
from sklearn.metrics import mean_absolute_error,mean_squared_error,r2_score

Flights1 = Flights.drop(['Org_Airport_Name','Origin_city','Dest_Airport_Name','Destination_city'],axis = 1)

Flights1['AIRLINE']= le.fit_transform(Flights1['AIRLINE'])
Flights1['ORIGIN_AIRPORT'] = le.fit_transform(Flights1['ORIGIN_AIRPORT'])
Flights1['DESTINATION_AIRPORT'] = le.fit_transform(Flights1['DESTINATION_AIRPORT'])

Flights1 = Flights1.drop(['Scheduled_Departure','Scheduled_Arrival','Actual_Arrival','Actual_Departure','ELAPSED_TIME','DIVERTED','AIR_TIME','DISTANCE'], axis = 1)

Flights1

X = Flights1.drop('ARRIVAL_DELAY',axis = 1)
X.shape

y = Flights1['ARRIVAL_DELAY']
y.head()

X_train,X_test,y_train,y_test = train_test_split(X,y,test_size=0.3)

X_train

sc1=StandardScaler()
X_train_sc=sc1.fit_transform(X_train)
X_test_sc=sc1.transform(X_test)
X_val=np.array([X.iloc[0]])
X_val_sc=sc1.fit_transform(X_val)

X_test

predictRfc=Rfc.fit(X_train,y_train)
predictedValues = predictRfc.predict(X_test)
print ('MAE:' ,  mean_absolute_error(y_test, predictedValues))
print ('MSE:' , mean_squared_error(y_test, predictedValues))
print('RMSE:' , np.sqrt(mean_squared_error(y_test, predictedValues)))
print ('R2:' , r2_score(y_test, predictedValues))

#import matplotlib.pyplot as plt
fig, ax = plt.subplots()
ax.scatter(y_test, predictedValues)
ax.plot([y.min(), y.max()], [y.min(), y.max()], 'k--', lw=4)
ax.set_xlabel('Actual')
ax.set_ylabel('Predicted')
plt.show()

df = pd.DataFrame({'Actual': y_test, 'Predicted': predictedValues})
df

Rfc.score(X_test, y_test)

X_test

X_val=np.array([[9,88,227,10.0,270,8.0,45.0]])
X_val

y_val=predictRfc.predict(X_val)

y_val



"""### Applying Decision Tree Regressor"""



from sklearn.tree import DecisionTreeRegressor
Dtc = DecisionTreeRegressor(random_state = 2)

fitResultdtc = Dtc.fit(X_train,y_train)
predictedValues = fitResultdtc.predict(X_test)
print ('MAE:' ,  mean_absolute_error(y_test, predictedValues))
print ('MSE:' , mean_squared_error(y_test, predictedValues))
print('RMSE:' , np.sqrt(mean_squared_error(y_test, predictedValues)))
print ('R2:' , r2_score(y_test, predictedValues))

#import matplotlib.pyplot as plt
fig, ax = plt.subplots()
ax.scatter(y_test, predictedValues)
ax.plot([y.min(), y.max()], [y.min(), y.max()], 'k--', lw=4)
ax.set_xlabel('Actual')
ax.set_ylabel('Predicted')
plt.show()

df = pd.DataFrame({'Actual': y_test, 'Predicted': predictedValues})
df

Dtc.score(X_test, y_test)

X_val=np.array([[9,88,227,10.0,270,8.0,45.0]])
X_val

y_val= fitResultdtc.predict(X_val)
y_val



"""### XGBoost Regresion"""

import xgboost as xg 
from sklearn.model_selection import train_test_split 
from sklearn.metrics import mean_squared_error as MSE 
xgb_r = xg.XGBRegressor(objective ='reg:linear', 
                  n_estimators = 1000) 
xgb_r.fit(X_train, y_train) 
predictedValues = xgb_r.predict(X_test) 
print ('MAE:' ,  mean_absolute_error(y_test, predictedValues))
print ('MSE:' , mean_squared_error(y_test, predictedValues))
print('RMSE:' , np.sqrt(mean_squared_error(y_test, predictedValues)))
print ('R2:' , r2_score(y_test, predictedValues))

#import matplotlib.pyplot as plt
fig, ax = plt.subplots()
ax.scatter(y_test, predictedValues)
ax.plot([y.min(), y.max()], [y.min(), y.max()], 'k--', lw=4)
ax.set_xlabel('Actual')
ax.set_ylabel('Predicted')
plt.show()

df = pd.DataFrame({'Actual': y_test, 'Predicted': predictedValues})
df

xgb_r.score(X_test, y_test)

X_val=np.array([[9,88,227,10.0,270,8.0,45.0]])
X_val

y_val= fitResultdtc.predict(X_val)
y_val

"""Functions"""

from sklearn.externals import joblib  
from sklearn.preprocessing import LabelEncoder
flightsinfo = pd.read_csv("drive/My Drive/flights.csv",nrows=50000)
airport = pd.read_csv('drive/My Drive/airports.csv')
airlines = pd.read_csv('drive/My Drive/airlines.csv')
from xgboost import XGBClassifier
classifierXGB = XGBClassifier(n_estimators=1000)
le = LabelEncoder()
flights=flightsinfo
Flights1 = flightsinfo
Flights1=flightsinfo.drop(['YEAR','MONTH','DAY','DAY_OF_WEEK','TAIL_NUMBER','DEPARTURE_TIME','WHEELS_OFF','WHEELS_ON','SCHEDULED_ARRIVAL','ARRIVAL_TIME','CANCELLATION_REASON','AIR_SYSTEM_DELAY','SECURITY_DELAY','AIRLINE_DELAY','LATE_AIRCRAFT_DELAY','WEATHER_DELAY'], axis = 1)
Flights1['Is_Delayed'] = np.where(Flights1['ARRIVAL_DELAY']<=0, 0,1)
Flights2=Flights1
airlines_dict = dict(zip(airlines['IATA_CODE'],airlines['AIRLINE']))
airport_dict = dict(zip(airport['IATA_CODE'],airport['AIRPORT']))
Flights1 = Flights1.dropna(subset = ['TAXI_IN','ARRIVAL_DELAY'])
X= Flights1.drop(['ELAPSED_TIME','DIVERTED','SCHEDULED_DEPARTURE','CANCELLED','FLIGHT_NUMBER','Is_Delayed','TAXI_IN'], axis = 1)
Flights1['DESC_AIRLINE'] = flightsinfo['AIRLINE'].apply(lambda x: airlines_dict[x])
Flights2['DESC_AIRLINE'] = flightsinfo['AIRLINE'].apply(lambda x: airlines_dict[x])
Flights1['Is_Delayed'] = np.where(Flights1['ARRIVAL_DELAY']<=0, 0,1)
X['AIRLINE']= le.fit_transform(X['AIRLINE'])
mapping = dict(zip(le.classes_, range(len(le.classes_))))
X['ORIGIN_AIRPORT'] = le.fit_transform(X['ORIGIN_AIRPORT'])
mapping = dict(zip(le.classes_, range(len(le.classes_))))
X['DESTINATION_AIRPORT'] = le.fit_transform(X['DESTINATION_AIRPORT'])
print(mapping['SEA'])
# X=X.drop(['ARRIVAL_DELAY'])
X = X.drop(['ARRIVAL_DELAY'],axis = 1)
y = Flights1['Is_Delayed']
classifierXGB.fit(X,y)
# print(X.columns)
joblib.dump(classifierXGB, 'drive/My Drive/xgbmodel.pkl')

from sklearn.externals import joblib  
from xgboost import XGBClassifier
from sklearn.preprocessing import LabelEncoder
classifierXGB = XGBClassifier(n_estimators=1000)
def recommend(src,dest):
  flightsinfo = pd.read_csv("drive/My Drive/flights.csv",nrows=200000)
  airport = pd.read_csv('drive/My Drive/airports.csv')
  airlines = pd.read_csv('drive/My Drive/airlines.csv')
  flights=flightsinfo
  Flights1 = flightsinfo
  Flights1=flightsinfo.drop(['YEAR','MONTH','DAY','DAY_OF_WEEK','TAIL_NUMBER','DEPARTURE_TIME','WHEELS_OFF','WHEELS_ON','SCHEDULED_ARRIVAL','ARRIVAL_TIME','CANCELLATION_REASON','AIR_SYSTEM_DELAY','SECURITY_DELAY','AIRLINE_DELAY','LATE_AIRCRAFT_DELAY','WEATHER_DELAY'], axis = 1)
  Flights1['Is_Delayed'] = np.where(Flights1['ARRIVAL_DELAY']<=0, 0,1)
  Flights2=Flights1
  Flights1=Flights1.loc[(Flights1['ORIGIN_AIRPORT'] == src)  | (Flights1['DESTINATION_AIRPORT'] == dest)]
  Flights2=Flights2.loc[(Flights2['ORIGIN_AIRPORT'] == src)  & (Flights2['DESTINATION_AIRPORT'] == dest)]
  airlines_dict = dict(zip(airlines['IATA_CODE'],airlines['AIRLINE']))
  airport_dict = dict(zip(airport['IATA_CODE'],airport['AIRPORT']))
  Flights1 = Flights1.dropna(subset = ['TAXI_IN','ARRIVAL_DELAY'])
  X= Flights1.drop(['ELAPSED_TIME','DIVERTED','SCHEDULED_DEPARTURE','CANCELLED','FLIGHT_NUMBER','Is_Delayed','TAXI_IN'], axis = 1)
  Flights1['DESC_AIRLINE'] = flightsinfo['AIRLINE'].apply(lambda x: airlines_dict[x])
  Flights2['DESC_AIRLINE'] = flightsinfo['AIRLINE'].apply(lambda x: airlines_dict[x])
  Flights1['Is_Delayed'] = np.where(Flights1['ARRIVAL_DELAY']<=0, 0,1)
  Flights2 = Flights2.dropna(subset = ['TAXI_IN','ARRIVAL_DELAY'])
  X['AIRLINE']= le.fit_transform(X['AIRLINE'])
  mapping = dict(zip(le.classes_, range(len(le.classes_))))
  # print(mapping['AS'])
  X['ORIGIN_AIRPORT'] = le.fit_transform(X['ORIGIN_AIRPORT'])
  mapping = dict(zip(le.classes_, range(len(le.classes_))))
  srcno=mapping[src]
  X['DESTINATION_AIRPORT'] = le.fit_transform(X['DESTINATION_AIRPORT'])
  X = X.drop(['ARRIVAL_DELAY'],axis = 1)
  mapping = dict(zip(le.classes_, range(len(le.classes_))))
  destno=mapping[dest]
  y = Flights1['Is_Delayed']
  X_test=X.loc[(X['ORIGIN_AIRPORT'] == srcno)  & (X['DESTINATION_AIRPORT'] == destno)]
  # return X_test
  xgb_from_joblib = joblib.load('drive/My Drive/xgbmodel.pkl')   
  y_pred=xgb_from_joblib.predict(X_test)
  Flights2['delayed']=y_pred
  Flights2=Flights2.loc[(Flights2['delayed'] == 0)]
  rank_airlines = pd.DataFrame(Flights2.groupby('DESC_AIRLINE').count()['SCHEDULED_DEPARTURE'])
  rank_airlines['CANCELLED']=Flights2.groupby('DESC_AIRLINE').sum()['CANCELLED']
  rank_airlines['OPERATED']=rank_airlines['SCHEDULED_DEPARTURE']-rank_airlines['CANCELLED']
  rank_airlines['RATIO_OP_SCH']=rank_airlines['OPERATED']/rank_airlines['SCHEDULED_DEPARTURE']
  rank_airlines.drop(rank_airlines.columns[[0,1,2]],axis=1,inplace=True)
  Flights2['FLIGHT_SPEED'] = 60*Flights2['DISTANCE']/Flights2['AIR_TIME']
  rank_airlines['FLIGHT_SPEED'] = Flights2.groupby('DESC_AIRLINE')['FLIGHT_SPEED'].mean()
  Flights2.groupby('DESC_AIRLINE')[['ARRIVAL_DELAY','DEPARTURE_DELAY']].mean()
  rank_airlines['ARRIVAL_DELAY']= Flights2.groupby('DESC_AIRLINE')['ARRIVAL_DELAY'].mean()
  rank_airlines['ARRIVAL_DELAY']=rank_airlines['ARRIVAL_DELAY'].apply(lambda x:x/60) 
  rank_airlines['FLIGHTS_VOLUME'] = Flights2.groupby('DESC_AIRLINE')['FLIGHT_NUMBER'].count()
  total = rank_airlines['FLIGHTS_VOLUME'].sum()
  rank_airlines['FLIGHTS_VOLUME'] = rank_airlines['FLIGHTS_VOLUME'].apply(lambda x:(x/float(total))) 
  for i in rank_airlines.columns:
      a = rank_airlines.RATIO_OP_SCH*rank_airlines.FLIGHT_SPEED*rank_airlines.FLIGHTS_VOLUME
      b = rank_airlines.ARRIVAL_DELAY
      rank_airlines['SCORE'] = a/(1+b)
      rank_airlines.sort_values(['SCORE'],ascending=False,inplace=True)
  return rank_airlines['SCORE']
recommend('ANC','SEA')

def percentageofdelay(src,dest,airlinesname):
  flightsinfo = pd.read_csv("drive/My Drive/flights.csv",nrows=200000)
  airport = pd.read_csv('drive/My Drive/airports.csv')
  airlines = pd.read_csv('drive/My Drive/airlines.csv')
  flights=flightsinfo
  Flights1 = flightsinfo
  Flights1=flightsinfo.drop(['YEAR','MONTH','DAY','DAY_OF_WEEK','TAIL_NUMBER','DEPARTURE_TIME','WHEELS_OFF','WHEELS_ON','SCHEDULED_ARRIVAL','ARRIVAL_TIME','CANCELLATION_REASON','AIR_SYSTEM_DELAY','SECURITY_DELAY','AIRLINE_DELAY','LATE_AIRCRAFT_DELAY','WEATHER_DELAY'], axis = 1)
  # Flights1['Is_Delayed'] = np.where(Flights1['ARRIVAL_DELAY']<=0, 0,1)
  Flights1=Flights1.loc[(Flights1['ORIGIN_AIRPORT'] == src)  & (Flights1['DESTINATION_AIRPORT'] == dest)  & (Flights1['AIRLINE'] == airlinesname)]
  Flights1['AIRLINE']= le.fit_transform(Flights1['AIRLINE'])
  mapping = dict(zip(le.classes_, range(len(le.classes_))))
  Flights1['ORIGIN_AIRPORT'] = le.fit_transform(Flights1['ORIGIN_AIRPORT'])
  mapping = dict(zip(le.classes_, range(len(le.classes_))))
  srcno=mapping[src]
  Flights1['DESTINATION_AIRPORT'] = le.fit_transform(Flights1['DESTINATION_AIRPORT'])
  Flights1 = Flights1.drop(['ARRIVAL_DELAY'],axis = 1)
  X_test=Flights1.drop(['ELAPSED_TIME','DIVERTED','SCHEDULED_DEPARTURE','CANCELLED','FLIGHT_NUMBER','TAXI_IN'], axis = 1)
  # return X_test
  xgb_from_joblib = joblib.load('drive/My Drive/xgbmodel.pkl')   
  y_pred=xgb_from_joblib.predict(X_test)
  Flights1['Is_Delayed']=y_pred
  totalcount=Flights1['Is_Delayed'].count()
  delayedcount=Flights1.loc[(Flights1['Is_Delayed'] == 1)]['Is_Delayed'].count()
  nodelayedcount=Flights1.loc[(Flights1['Is_Delayed'] == 0)]['Is_Delayed'].count()
  axis = plt.subplots(figsize=(10,14))
  Name = ['Delayed','Not Delayed']
  values = [(delayedcount/totalcount)*100,(nodelayedcount/totalcount)*100]
  plt.pie(values,labels=Name,autopct='%5.0f%%')
  plt.savefig('drive/My Drive/foo.png')
  return plt.show()
percentageofdelay('LAX','BOS','AA')

def dornot_result(airlines_name,origin_airport,dest_airport,distance,departure_delay,scheduled_time,airtime,taxi_out):
  xgb_from_joblib = joblib.load('drive/My Drive/xgbmodel.pkl')  
  data = [[airlines_name,origin_airport,dest_airport,departure_delay,taxi_out,scheduled_time,airtime,distance]]
  df_final = pd.DataFrame(data,columns=['AIRLINE','ORIGIN_AIRPORT','DESTINATION_AIRPORT','DEPARTURE_DELAY','TAXI_OUT','SCHEDULED_TIME','AIR_TIME','DISTANCE'])
  y_final_val=xgb_from_joblib.predict(df_final)
  return y_final_val
dornot_result(0,15,265,1448,-11.0,205,169.0,21.0)

